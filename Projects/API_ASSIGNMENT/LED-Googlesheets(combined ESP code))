// Combined main.cpp for ESP8266 (PlatformIO)
// BTN1 (D3 / GPIO0): fetch JSON -> control LED + RGB
// BTN2 (D4 / GPIO2): read DHT11 -> send to Google Apps Script
// NEW: Interrupt-driven queue so presses during long work are not missed.

#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <WiFiClientSecureBearSSL.h>
#include <ESP8266HTTPClient.h>
#include <ArduinoJson.h>
#include "DHT.h"

// ======== WIFI (shared) ========
const char* WIFI_SSID = "NETGEAR35";
const char* WIFI_PASS = "rapidrabbit565";

// ======== ENDPOINTS ========
const char* STATE_URL  = "https://nickkaemer.com/results.txt"; // JSON for LED/RGB
const char* SCRIPT_URL =
  "https://script.google.com/macros/s/AKfycbyCfkwiN6fx2OO8foIe3YA7bTgUee3uwYbcDaVHYiHaajliPbeaf0q8orrculm9Awc/exec"; // Sheet logging

// ======== PINS ========
const int LED_PIN  = 5;   // D1 (GPIO5)
const int BTN1_PIN = 0;   // D3 (GPIO0)  -> GND (INPUT_PULLUP)
const int RGB_R    = 14;  // D5 (GPIO14)
const int RGB_G    = 12;  // D6 (GPIO12)
const int RGB_B    = 13;  // D7 (GPIO13)
#define  DHT_PIN   D2     // GPIO4
#define  DHT_TYPE  DHT11
const int BTN2_PIN = D4;  // GPIO2 (D4)  -> GND (INPUT_PULLUP)

DHT dht(DHT_PIN, DHT_TYPE);

// ======== Task queue (bitmask) ========
enum Task : uint8_t { TASK_NONE = 0, TASK_JSON = 1, TASK_DHT = 2 };

// Queue drained in loop(); presses are added from ISRs.
static volatile uint8_t isrPendingBits = 0;   // set by ISRs only
static uint8_t pendingTasks = 0;              // consumed in loop()

// ======== Interrupt debouncing ========
// Use short debounce inside ISR to avoid multiple queue adds due to bounce.
static const uint16_t ISR_DEBOUNCE_MS = 120;
static volatile uint32_t lastIsrBtn1 = 0;
static volatile uint32_t lastIsrBtn2 = 0;

// NOTE: On ESP8266 the attribute is ICACHE_RAM_ATTR
void ICACHE_RAM_ATTR onBtn1Fall() {
  uint32_t now = millis();
  if (now - lastIsrBtn1 > ISR_DEBOUNCE_MS) {
    isrPendingBits |= TASK_JSON;   // record a JSON task
    lastIsrBtn1 = now;
  }
}
void ICACHE_RAM_ATTR onBtn2Fall() {
  uint32_t now = millis();
  if (now - lastIsrBtn2 > ISR_DEBOUNCE_MS) {
    isrPendingBits |= TASK_DHT;    // record a DHT task
    lastIsrBtn2 = now;
  }
}

// ======== WiFi helper ========
void wifiConnect() {
  if (WiFi.status() == WL_CONNECTED) return;
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.printf("Connecting to %s", WIFI_SSID);
  uint32_t start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    Serial.print(".");
    if (millis() - start > 20000) {
      Serial.println("\nWiFi connect timeout, retrying...");
      WiFi.disconnect();
      delay(500);
      WiFi.begin(WIFI_SSID, WIFI_PASS);
      start = millis();
    }
  }
  Serial.printf("\nWiFi connected! IP=%s\n", WiFi.localIP().toString().c_str());
}

// ======== HTTPS GET (shared) ========
int httpsGET(const String& url, String& bodyOut) {
  std::unique_ptr<BearSSL::WiFiClientSecure> client(new BearSSL::WiFiClientSecure);
  client->setInsecure();            // for demo
  client->setBufferSizes(512, 512);

  HTTPClient http;
  Serial.println("GET -> " + url);
  if (!http.begin(*client, url)) { Serial.println("http.begin() failed"); return -999; }

  http.useHTTP10(true);
  http.setTimeout(15000);
  http.setReuse(false);

  int code = http.GET();
  if (code > 0) bodyOut = http.getString();
  http.end();
  return code;
}

// ======== JSON -> LED/RGB ========
String readJsonOnce() {
  wifiConnect();
  delay(100);
  String body;
  int code = httpsGET(STATE_URL, body);
  Serial.printf("<- HTTPS %d\n", code);
  if (code == HTTP_CODE_OK) {
    body.trim();
    Serial.println("Body: " + body);
    return body;
  }
  Serial.println("Failed to fetch JSON");
  return "";
}

static inline int clamp255(int v){ return (v < 0 ? 0 : (v > 255 ? 255 : v)); }

bool applyFromJson(const String& json) {
  if (json.length() == 0) return false;

  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, json);
  if (err) {
    Serial.print("JSON parse error: ");
    Serial.println(err.c_str());
    return false;
  }

  const char* led = doc["led"] | "OFF";
  int r = clamp255(doc["rgb"]["r"] | 0);
  int g = clamp255(doc["rgb"]["g"] | 0);
  int b = clamp255(doc["rgb"]["b"] | 0);

  bool on = (strcmp(led, "ON") == 0);

  if (on) {
    digitalWrite(LED_PIN, HIGH);
    analogWrite(RGB_R, r);
    analogWrite(RGB_G, g);
    analogWrite(RGB_B, b);
    Serial.printf("LED: ON  RGB(%d,%d,%d)\n", r, g, b);
  } else {
    digitalWrite(LED_PIN, LOW);
    analogWrite(RGB_R, 0);
    analogWrite(RGB_G, 0);
    analogWrite(RGB_B, 0);
    Serial.println("LED: OFF  RGB(0,0,0)");
  }
  return true;
}

// ======== DHT -> Google Sheet ========
bool sendToSheet(float tempC) {
  String url = String(SCRIPT_URL) + "?sensor=" + String(tempC, 1);

  std::unique_ptr<BearSSL::WiFiClientSecure> client(new BearSSL::WiFiClientSecure);
  client->setInsecure();

  HTTPClient http;
  http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
  http.setTimeout(15000);

  Serial.println("GET -> " + url);
  if (!http.begin(*client, url)) { Serial.println("http.begin failed"); return false; }

  int code = http.GET();
  String body = (code > 0) ? http.getString() : "";
  http.end();

  Serial.printf("<- HTTPS %d\n", code);
  if (body.length()) Serial.println(body);
  return (code > 0);
}

void sendReadingOnce() {
  float t = dht.readTemperature(); // Celsius
  if (isnan(t)) { Serial.println("DHT read failed"); return; }
  Serial.printf("Temp = %.1f C\n", t);
  wifiConnect();
  if (sendToSheet(t)) Serial.println("Logged âœ”");
  else Serial.println("Send failed");
}

// ======== setup/loop ========
void setup() {
  Serial.begin(9600);

  pinMode(LED_PIN, OUTPUT);  digitalWrite(LED_PIN, LOW);
  pinMode(BTN1_PIN, INPUT_PULLUP);
  pinMode(BTN2_PIN, INPUT_PULLUP);

  pinMode(RGB_R, OUTPUT);
  pinMode(RGB_G, OUTPUT);
  pinMode(RGB_B, OUTPUT);
  analogWriteRange(255);

  dht.begin();
  wifiConnect();

  // Initial JSON sync
  String json = readJsonOnce();
  applyFromJson(json);

  // Attach interrupts on falling edge (pressed -> GND)
  attachInterrupt(digitalPinToInterrupt(BTN1_PIN), onBtn1Fall, FALLING);
  attachInterrupt(digitalPinToInterrupt(BTN2_PIN), onBtn2Fall, FALLING);

  Serial.println("Ready. BTN1 (D3) -> JSON sync; BTN2 (D4) -> send DHT reading.");
}

inline Task nextTaskFromMask(uint8_t &mask) {
  if (mask & TASK_JSON) { mask &= ~TASK_JSON; return TASK_JSON; }
  if (mask & TASK_DHT)  { mask &= ~TASK_DHT;  return TASK_DHT;  }
  return TASK_NONE;
}

void loop() {
  // 1) Atomically grab any ISR-captured presses and move them into the queue.
  noInterrupts();
  uint8_t newlyPressed = isrPendingBits;
  isrPendingBits = 0;
  interrupts();
  pendingTasks |= newlyPressed;

  // 2) Run at most one task per loop (serialized work).
  Task t = nextTaskFromMask(pendingTasks);
  if (t == TASK_JSON) {
    Serial.println("Run: fetch/apply JSON");
    String j = readJsonOnce();
    applyFromJson(j);
  } else if (t == TASK_DHT) {
    Serial.println("Run: read DHT + send");
    sendReadingOnce();
  }

  delay(5);
}
